<?php


namespace App\Contracts;

/**
 * Используйте эти грёбанные пространства имён тут, не надо размазывать их по коду
 * вероятность совпадения имён классов крайне низка, и даже для этих случаев есть Alias'ы
 * и пишите код в одном стиле, не нужно ничего "сочинять", мы пишем КОММЕРЧЕСКИЙ проект,
 * а не Ваш личный блог про то, как правильно кормить котов
 *
 * и да, "контракты" бывают и просто классами, я понимаю, что для многих это не очевидно
 * и не каждому дано это понять... но, просто примите это как неизбежность, как факт
 *
 * P.S. Для тех кто "в танке", почему это "контракт"? Ну, во первых, по тому, что это КОНТРАКТ.
 * Во вторых, по тому, что в Laravel есть такая штука как "Contextual binding"
 * для тех кто про неё не слышал, почитать можно тут https://laravel.com/docs/8.x/container#contextual-binding
 * И этот КОНТРАКТ можно использовать точно так же как и любой другой, но для эстетов, конечно же,
 * можно его превратить в Интерфейс и создать отдельный Класс /app/Exceptions/DriverException,
 * забиндить его в качестве реализации по умолчанию... хотя, я не знаю как это тогда отработает в коде в целом,
 * мне уже лень проверять, сделайте это сами.
 *
 * Да, и с помощью "Contextual binding", если верить документации - то можно подсунуть нужную конечную реализацию
 * в нужный метод нужного класса. Как это работает - я тоже пока не проверял, так как пока не смог придумать
 * ни одного кейса, в котором объект конечной ошибки от страховой, внезапно, должен настолько трансформироваться,
 * что стандартный/общий объект для этих целей подходить уже перестанет и точечно нужно будет внедрять строго другой
 * объект ошибки на уровне отдельно взятого ДРАЙВЕРА (для тех кто не заметил, это именно объект ошибки ДРАЙВЕРА,
 * любого конечного драйвера, а не всей "вселенной").
 */

use Exception;
use Throwable;

class DriverExceptionContract extends Exception implements Throwable
{
    /**
     * Конструктор можно расширить по желанию, или добавить недостающие на Ваш взгляд методы
     * (скорее всего, геттеры/сеттеры) или просто добавить к этому классу желаемое количество
     * недостающих свойств
     *
     * DriverExceptionContract constructor.
     * @param string $message
     * @param int $code
     * @param Throwable|null $previous
     */
    public function __construct($message = "", $code = 0, Throwable $previous = null)
    {
        parent::__construct($message, $code, $previous);
    }

    /**
     * Для особо рьяных поборников ООП - можно изменить модификатор на "protected"
     * Да, зачем эта херня (переменная) вообще нужна? - просто как пример, того, что не нужно плодить новые классы
     * на каждый чих, достаточно сделать 1 класс который будет отвечать конкретно за "Ошибки драйверов".
     * Если Вы знакомы с основными принципами ООП - это максимально очевидный момент. Драйверы (классы драйверов)
     * создающиеся по шаблону - вероятно и ошибки должны возвращать по такому же точно шаблону? Не нужно плодить
     * пустые и ОДИНАКОВЫЕ классы, ко всему прочему ещё и одинаково пустые.
     */
    public $additionalData = null;

    /**
     * Пример переменной с модификатором "protected"
     */
    protected $class = null;

    /**
     * Сеттер обыкновенный
     *
     * @param $class
     * @return mixed
     */
    public function setClass($class) {
        return $this->class = $class;
    }

    /**
     * Геттер, не менее обыкновенный нежели и сеттер
     *
     * @param $class
     * @return mixed
     */
    public function getClass() {
        return $this->class;
    }
}
